package work.myfavs.framework.orm;

import cn.hutool.core.collection.CollUtil;
import work.myfavs.framework.orm.meta.handler.PropertyHandlerFactory;
import work.myfavs.framework.orm.util.convert.DBConvert;
import work.myfavs.framework.orm.util.exception.DBException;
import work.myfavs.framework.orm.util.func.ThrowingConsumer;

import java.io.Closeable;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;

/**
 * 查询封装
 */
public class Query implements Closeable {
  private final Database database;
  private final int      batchSize;
  private final int      fetchSize;

  private PreparedStatement preparedStatement;
  private String            sql;
  private boolean           autoGeneratedPK  = false;
  //当前查询的 batchSize，默认值为 1，如果 > 1，则按批量查询处理
  private int               currentBatchSize = 1;

  //批量查询参数
  private final Map<Integer/*batchSize*/, Map<Integer/*paramIndex*/, Object>> batchParameters = new LinkedHashMap<>();

  /**
   * 构造方法，推荐使用 {@link Database#createQuery(String, boolean)} 创建示例
   *
   * @param database        {@link Database}
   * @param sql             SQL语句
   * @param autoGeneratedPK 是否自动生成主键
   */
  public Query(Database database, String sql, boolean autoGeneratedPK) {
    this.database = database;
    this.batchSize = database.getDbConfig().getBatchSize();
    this.fetchSize = database.getDbConfig().getFetchSize();
    initQuery(sql, autoGeneratedPK);
  }

  private void initQuery(String sql, boolean autoGeneratedPK) {
    this.sql = sql;
    this.autoGeneratedPK = autoGeneratedPK;
    this.clearParameters();
    this.closePreparedStatement();
  }

  /**
   * 创建一个新的 Query 对象(默认不自动生成主键)
   *
   * @param sql SQL语句
   * @return {@link Query}
   */
  public Query newQuery(String sql) {
    return newQuery(sql, false);
  }

  /**
   * 创建一个新的 Query 对象
   *
   * @param sql             SQL语句
   * @param autoGeneratedPK 是否自动生成主键
   * @return {@link Query}
   */
  public Query newQuery(String sql, boolean autoGeneratedPK) {
    initQuery(sql, autoGeneratedPK);
    return this;
  }

  /**
   * 创建 PreparedStatement
   *
   * @return {@link PreparedStatement}
   */
  private PreparedStatement createPreparedStatement() {
    try {
      if (this.preparedStatement == null) {
        if (this.autoGeneratedPK)
          this.preparedStatement = this.database.getConnection().prepareStatement(this.sql, Statement.RETURN_GENERATED_KEYS);
        else
          this.preparedStatement = this.database.getConnection().prepareStatement(this.sql);
      }
    } catch (SQLException e) {
      throw new DBException(e, "Error preparing statement: {}", e.getMessage());
    }
    return this.preparedStatement;
  }

  /**
   * 批量增加参数
   *
   * @param params 参数集合
   * @return {@link Database}
   */
  public Query addParameters(Collection<?> params) {
    Map<Integer, Object> parameters = batchParameters.get(currentBatchSize);
    int                  paramIndex = parameters.size();
    for (Object param : params) {
      parameters.put(++paramIndex, param);
    }
    return this;
  }

  /**
   * 增加参数
   *
   * @param paramIndex 参数序号，从 1 开始
   * @param param      参数
   * @return {@link Database}
   */
  public Query addParameter(int paramIndex, Object param) {
    Map<Integer, Object> parameters = batchParameters.get(currentBatchSize);

    if (parameters.containsKey(paramIndex))
      throw new DBException("Error adding parameter: error index {}", paramIndex);

    parameters.put(paramIndex, param);
    return this;
  }


  /**
   * 处理参数
   *
   * @param statement {@link PreparedStatement}
   */
  private void applyParameters(PreparedStatement statement) {
    try {
      if (this.currentBatchSize > 1) {
        applyBatchParameters(statement, this.batchParameters, this.batchSize);
      } else {
        applyNormalParameters(statement, this.batchParameters.get(this.currentBatchSize));
      }
    } catch (SQLException ex) {
      throw new DBException(ex, "Error adding parameter: {}", ex.getMessage());
    }
  }

  @SuppressWarnings("unchecked")
  private static void applyNormalParameters(
      PreparedStatement statement,
      Map<Integer, Object> parameters) throws SQLException {
    if (CollUtil.isEmpty(parameters)) return;
    for (Map.Entry<Integer, Object> paramEntry : parameters.entrySet()) {
      int    paramIndex = paramEntry.getKey();
      Object param      = paramEntry.getValue();
      if (Objects.isNull(param)) {
        statement.setObject(paramIndex, null);
      } else {
        PropertyHandlerFactory
            .getInstance(param.getClass())
            .addParameter(statement, paramIndex, param);
      }
    }
  }

  private static void applyBatchParameters(
      PreparedStatement statement,
      Map<Integer, Map<Integer, Object>> batchParameters,
      int batchSize) throws SQLException {
    for (Map.Entry<Integer, Map<Integer, Object>> parametersEntry : batchParameters.entrySet()) {
      Map<Integer, Object> parameters = parametersEntry.getValue();
      if (CollUtil.isEmpty(parameters)) continue;

      applyNormalParameters(statement, parameters);
      statement.addBatch();
      if (batchSize > 0) {
        int curBatchSize = parametersEntry.getKey();
        if (curBatchSize % batchSize == 0) {
          statement.executeBatch();
        }
      }
    }
  }

  public <TModel> List<TModel> find(Class<TModel> modelClass) {
    PreparedStatement preparedStatement = createPreparedStatement();
    setFetchSize(preparedStatement);
    applyParameters(preparedStatement);
    try (ResultSet resultSet = preparedStatement.executeQuery()) {
      return DBConvert.toList(modelClass, resultSet);
    } catch (SQLException ex) {
      throw new DBException(ex, "Error execute query: {}", ex.getMessage());
    } finally {
      clearParameters();
    }
  }

  public <TModel> TModel get(Class<TModel> modelClass) {
    Iterator<TModel> iterator = find(modelClass).iterator();
    return iterator.hasNext() ? iterator.next() : null;
  }

  private void setFetchSize(PreparedStatement preparedStatement) {
    try {
      if (this.fetchSize > 0)
        preparedStatement.setFetchSize(this.fetchSize);
    } catch (SQLException ex) {
      throw new DBException(ex, "Error set fetch size: {}", ex.getMessage());
    }
  }

  public int execute(ThrowingConsumer<PreparedStatement, SQLException> configConsumer,
                     ThrowingConsumer<ResultSet, SQLException> keyConsumer) {
    PreparedStatement preparedStatement = createPreparedStatement();
    try {
      if (Objects.nonNull(configConsumer))
        configConsumer.accept(preparedStatement);
      applyParameters(preparedStatement);
      int result = preparedStatement.executeUpdate();
      if (Objects.nonNull(keyConsumer)) {
        if (this.autoGeneratedPK) {
          try (ResultSet resultSet = preparedStatement.getGeneratedKeys()) {
            keyConsumer.accept(resultSet);
          }
        }
      }
      return result;
    } catch (SQLException e) {
      throw new DBException(e, "Error execute update: {}", e.getMessage());
    } finally {
      clearParameters();
    }
  }

  /**
   * 清空所有参数
   */
  private void clearParameters() {
    this.currentBatchSize = 1;
    this.batchParameters.clear();
    this.batchParameters.put(this.currentBatchSize, new HashMap<>());
  }

  public int execute() {
    return this.execute(null, null);
  }

  /**
   * 调用 {@link PreparedStatement#addBatch()} 并提交执行
   */
  public void addBatch() {
    batchParameters.put(++currentBatchSize, new HashMap<>());
  }

  public int[] executeBatch(ThrowingConsumer<ResultSet, SQLException> consumer) {
    PreparedStatement preparedStatement = createPreparedStatement();
    try {
      applyParameters(preparedStatement);
      int[] result = preparedStatement.executeBatch();
      if (Objects.nonNull(consumer)) {
        if (this.autoGeneratedPK) {
          try (ResultSet resultSet = preparedStatement.getGeneratedKeys()) {
            consumer.accept(resultSet);
          }
        }
      }
      return result;
    } catch (SQLException e) {
      throw new DBException(e, "Error execute batch: {}", e.getMessage());
    } finally {
      clearParameters();
    }
  }

  public int[] executeBatch() {
    return executeBatch(null);
  }

  @Override
  public void close() {
    closePreparedStatement();
  }

  private void closePreparedStatement() {
    if (this.preparedStatement != null) {
      try {
        if (!this.preparedStatement.isClosed())
          this.preparedStatement.close();
      } catch (SQLException e) {
        throw new DBException(e, "Error close preparedStatement: {}", e.getMessage());
      } finally {
        this.preparedStatement = null;
      }
    }
  }
}
