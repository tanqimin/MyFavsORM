package work.myfavs.framework.orm;

import work.myfavs.framework.orm.meta.BatchParameters;
import work.myfavs.framework.orm.meta.SqlLog;
import work.myfavs.framework.orm.util.common.CollectionUtil;
import work.myfavs.framework.orm.util.convert.DBConvert;
import work.myfavs.framework.orm.util.exception.DBException;
import work.myfavs.framework.orm.util.func.ThrowingConsumer;

import java.io.Closeable;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;

/**
 * 对 JDBC 查询基本封装
 */
public class Query implements Closeable {
  private final Database          database;
  private final int               batchSize;
  private final int               fetchSize;
  private final SqlLog            sqlLog;
  private       PreparedStatement preparedStatement;
  private       String            sql;
  private       boolean           autoGeneratedPK = false;


  //批量查询参数
  private final BatchParameters batchParameters = new BatchParameters();

  /**
   * 构造方法，推荐使用 {@link Database#createQuery(String, boolean)} 创建示例
   *
   * @param database        {@link Database}
   * @param sql             SQL语句
   * @param autoGeneratedPK 是否自动生成主键
   */
  public Query(Database database, String sql, boolean autoGeneratedPK) {
    this.database = database;
    this.batchSize = database.getDbConfig().getBatchSize();
    this.fetchSize = database.getDbConfig().getFetchSize();
    this.sqlLog = new SqlLog(
        database.getDbConfig().getShowSql(),
        database.getDbConfig().getShowResult()
    );

    createQuery(sql, autoGeneratedPK);
  }

  /**
   * 创建一个新的 Query 对象(默认不自动生成主键)
   *
   * @param sql SQL语句
   * @return {@link Query}
   */
  public Query createQuery(String sql) {
    return createQuery(sql, false);
  }

  /**
   * 创建一个新的 Query 对象
   *
   * @param sql             SQL语句
   * @param autoGeneratedPK 是否自动生成主键
   * @return {@link Query}
   */
  public Query createQuery(String sql, boolean autoGeneratedPK) {
    this.sql = sql;
    this.autoGeneratedPK = autoGeneratedPK;
    this.batchParameters.clear();
    this.closePreparedStatement();
    this.sqlLog.showSql(sql);
    return this;
  }

  /**
   * 创建 PreparedStatement
   *
   * @return {@link PreparedStatement}
   */
  private PreparedStatement createPreparedStatement() {
    try {
      if (Objects.isNull(this.preparedStatement)) {
        if (this.autoGeneratedPK)
          this.preparedStatement = this.database.getConnection().prepareStatement(this.sql, Statement.RETURN_GENERATED_KEYS);
        else
          this.preparedStatement = this.database.getConnection().prepareStatement(this.sql);
      }
    } catch (SQLException e) {
      throw new DBException(e, "Error preparing statement: %s", e.getMessage());
    }
    return this.preparedStatement;
  }

  /**
   * 批量增加参数
   *
   * @param params 参数集合
   * @return {@link Query}
   */
  public Query addParameters(Collection<?> params) {
    if (CollectionUtil.isEmpty(params)) return this;
    this.batchParameters.getCurrentBatchParameters().addParameters(params);
    return this;
  }

  /**
   * 增加参数
   *
   * @param paramIndex 参数序号，从 1 开始
   * @param param      参数
   * @return {@link Query}
   */
  public Query addParameter(int paramIndex, Object param) {
    this.batchParameters.getCurrentBatchParameters().addParameter(paramIndex, param);
    return this;
  }

  /**
   * 增加参数，根据现有参数数量设置序号
   *
   * @param param 参数
   * @return {@link Query}
   */
  public Query addParameter(Object param) {
    this.batchParameters.getCurrentBatchParameters().addParameter(param);
    return this;
  }

  /**
   * 执行查询，并返回指定类型的实体集合
   *
   * @param modelClass 实体类型
   * @param <TModel>   实体类型泛型
   * @return 实体集合
   */
  public <TModel> List<TModel> find(Class<TModel> modelClass) {
    final PreparedStatement preparedStatement = createPreparedStatement();
    this.setFetchSize(preparedStatement);
    this.batchParameters.applyParameters(preparedStatement);
    this.sqlLog.showParams(this.batchParameters);

    try (final ResultSet resultSet = this.sqlLog.showExecutionTimeReturn(
        preparedStatement::executeQuery,
        executionTime -> String.format("Query execution time : %d ms", executionTime))) {

      final List<TModel> result = this.sqlLog.showExecutionTimeReturn(
          () -> DBConvert.toList(modelClass, resultSet),
          executionTime -> String.format("ResultSet convert execution time : %d ms", executionTime));

      return this.sqlLog.showResult(modelClass, result);
    } catch (SQLException ex) {
      throw new DBException(ex, "Error execute query: %s", ex.getMessage());
    } finally {
      this.batchParameters.clear();
    }
  }

  /**
   * 执行查询，并返回指定类型的实体
   *
   * @param modelClass 实体类型
   * @param <TModel>   实体类型泛型
   * @return 实体
   */
  public <TModel> TModel get(Class<TModel> modelClass) {
    final Iterator<TModel> iterator = find(modelClass).iterator();
    return iterator.hasNext() ? iterator.next() : null;
  }

  private void setFetchSize(PreparedStatement preparedStatement) {
    try {
      if (this.fetchSize > 0)
        preparedStatement.setFetchSize(this.fetchSize);
    } catch (SQLException ex) {
      throw new DBException(ex, "Error set fetch size: %s", ex.getMessage());
    }
  }

  /**
   * 执行查询，返回影响行数
   *
   * @param configConsumer 在执行查询前允许，可对 PreparedStatement 进行设置
   * @param keysConsumer   在执行查询后执行，对于 {@code autoGeneratedPK = true} 则可返回 {@link ResultSet} 获取生成的 Key 值
   * @return 影响行数
   */
  public int execute(ThrowingConsumer<PreparedStatement, SQLException> configConsumer,
                     ThrowingConsumer<ResultSet, SQLException> keysConsumer) {
    final PreparedStatement preparedStatement = createPreparedStatement();
    try {
      if (Objects.nonNull(configConsumer))
        configConsumer.accept(preparedStatement);
      this.batchParameters.applyParameters(preparedStatement);
      this.sqlLog.showParams(this.batchParameters);

      final int result = this.sqlLog.showExecutionTimeReturn(
          preparedStatement::executeUpdate,
          executionTime -> String.format("Execute update execution time : %d ms", executionTime));

      this.generatedKeys(preparedStatement, keysConsumer);
      return this.sqlLog.showAffectedRows(result);
    } catch (SQLException e) {
      throw new DBException(e, "Error execute update: %s", e.getMessage());
    } finally {
      this.batchParameters.clear();
    }
  }

  /**
   * 执行查询，返回影响行数
   *
   * @return 影响行数
   */
  public int execute() {
    return this.execute(null, null);
  }

  /**
   * 调用 {@link PreparedStatement#addBatch()} 并提交执行
   */
  public void addBatch() {
    this.batchParameters.addBatch();
  }

  /**
   * 执行批量查询，返回数组，包含每个查询的影响行数
   *
   * @param keysConsumer 在执行查询后执行，对于 {@code autoGeneratedPK = true} 则可返回 {@link ResultSet} 获取生成的 Key 值
   * @return 返回数组，包含每个查询的影响行数
   */
  public int[] executeBatch(ThrowingConsumer<ResultSet, SQLException> keysConsumer) {
    final PreparedStatement preparedStatement = createPreparedStatement();
    try {
      this.batchParameters.applyBatchParameters(preparedStatement, this.batchSize);
      this.sqlLog.showParams(this.batchParameters);

      final int[] result = this.sqlLog.showExecutionTimeReturn(
          preparedStatement::executeBatch,
          executionTime -> String.format("Execute update execution time : %d ms", executionTime));

      this.generatedKeys(preparedStatement, keysConsumer);
      this.sqlLog.showAffectedRows(result.length);
      return result;
    } catch (SQLException e) {
      throw new DBException(e, "Error execute batch: %s", e.getMessage());
    } finally {
      this.batchParameters.clear();
    }
  }

  /**
   * 执行批量查询，返回数组，包含每个查询的影响行数
   *
   * @return 返回数组，包含每个查询的影响行数
   */
  public int[] executeBatch() {
    return executeBatch(null);
  }

  /**
   * 释放 PreparedStatement
   */
  @Override
  public void close() {
    closePreparedStatement();
  }

  /**
   * 生成主键
   *
   * @param preparedStatement {@link PreparedStatement}
   * @param keysConsumer      在执行查询后执行，对于 {@code autoGeneratedPK = true} 则可返回 {@link ResultSet} 获取生成的 Key 值
   * @throws SQLException 异常 {@see SQLException}
   */
  private void generatedKeys(PreparedStatement preparedStatement, ThrowingConsumer<ResultSet, SQLException> keysConsumer) throws SQLException {
    if (Objects.isNull(keysConsumer)) return;
    if (!this.autoGeneratedPK) return;
    try (final ResultSet resultSet = this.sqlLog.showExecutionTimeReturn(
        preparedStatement::getGeneratedKeys,
        executionTime -> String.format("Get generated key execution time : %d ms", executionTime))) {

      this.sqlLog.showExecutionTime(
          () -> keysConsumer.accept(resultSet),
          executionTime -> String.format("Generated key ResultSet convert execution time : %d ms", executionTime));

    }
  }

  private void closePreparedStatement() {
    if (Objects.nonNull(this.preparedStatement)) {
      try {
        if (!this.preparedStatement.isClosed())
          this.preparedStatement.close();
      } catch (SQLException e) {
        throw new DBException(e, "Error close preparedStatement: %s", e.getMessage());
      } finally {
        this.preparedStatement = null;
      }
    }
  }
}
