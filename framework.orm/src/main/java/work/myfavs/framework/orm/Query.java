package work.myfavs.framework.orm;

import cn.hutool.core.collection.CollUtil;
import cn.hutool.core.lang.Assert;
import cn.hutool.core.util.StrUtil;
import work.myfavs.framework.orm.meta.DbType;
import work.myfavs.framework.orm.meta.dialect.IDialect;
import work.myfavs.framework.orm.meta.handler.PropertyHandlerFactory;
import work.myfavs.framework.orm.meta.schema.Attribute;
import work.myfavs.framework.orm.util.SqlLog;
import work.myfavs.framework.orm.util.convert.DBConvert;
import work.myfavs.framework.orm.util.exception.DBException;
import work.myfavs.framework.orm.util.func.ThrowingConsumer;

import java.io.Closeable;
import java.sql.*;
import java.util.Collection;
import java.util.List;
import java.util.Objects;

public class Query implements Closeable {

  protected final DBTemplate  dbTemplate;
  protected final SqlLog      sqlLog;
  protected final ConnFactory connFactory;

  private PreparedStatement statement;
  private ResultSet         resultSet;
  private boolean           autoGeneratedPK  = false;
  /**
   * 当执行 {@link PreparedStatement#addBatch()} 时记录当前参数的数量
   */
  private int               currentBatchSize = 0;


  /**
   * 构造方法，建议使用 {@link DBTemplate#createDatabase()} 创建
   *
   * @param dbTemplate {@link DBTemplate}
   */
  public Query(DBTemplate dbTemplate) {
    this.dbTemplate = dbTemplate;
    this.connFactory = dbTemplate.getConnectionFactory();
    this.sqlLog = new SqlLog(dbTemplate);
    this.open();
  }

  /**
   * 判断当前是否使用 SQL Server 数据库
   *
   * @return 如果是返回 {@code true}，否则返回 {@code false}
   */
  protected boolean isSqlServer() {
    return StrUtil.equals(getDbConfig().getDbType(), DbType.SQL_SERVER)
        || StrUtil.equals(getDbConfig().getDbType(), DbType.SQL_SERVER_2012);
  }

  /**
   * 判断当前是否使用 MySql 数据库
   *
   * @return 如果是返回 {@code true}，否则返回 {@code false}
   */
  protected boolean isMySql() {
    return StrUtil.equals(getDbConfig().getDbType(), DbType.MYSQL);
  }

  /**
   * 获取ORM数据库配置
   *
   * @return {@link DBTemplate#getDbConfig()}
   */
  protected DBConfig getDbConfig() {
    return this.dbTemplate.getDbConfig();
  }

  /**
   * 获取数据库方言
   *
   * @return {@link DBConfig#getDialect()}
   */
  protected IDialect getDialect() {
    return this.dbTemplate.getDbConfig().getDialect();
  }

  public Connection getConnection() {
    return this.connFactory.getCurrentConnection();
  }

  /**
   * 打开数据库连接，需要与 {@link #close()} 配对使用
   *
   * @return 如果连接不存在，则创建，否则记录数据库连接打开次数 {@code +1}，并返回 {@link ConnFactory#openConnection()}
   */
  public Query open() {
    this.connFactory.openConnection();
    return this;
  }


  /**
   * 释放数据库资源，与 {@link #open()} 配对使用 <br/>
   * 如果数据库连接打开次数 {@code > 1} ，则记录数据库连接次数 {@code -1} <br/>
   * 如果数据库连接打开次数 {@code = 1} ，则关闭数据库连接
   */
  @Override
  public void close() {
    try {
      //关闭 ResultSet
      if (Objects.nonNull(this.resultSet)) {
        if (!this.resultSet.isClosed())
          this.resultSet.close();
      }
    } catch (SQLException ex) {
      throw new DBException(ex, "Error close ResultSet: {}", ex.getMessage());
    } finally {
      closeStatementAndConnection();
    }
  }

  private void closeStatementAndConnection() {
    try {
      //关闭 Statement
      if (Objects.nonNull(this.statement)) {
        if (!this.statement.isClosed())
          this.statement.close();
      }
    } catch (SQLException ex) {
      throw new DBException(ex, "Error close ResultSet: {}", ex.getMessage());
    } finally {
      //关闭数据库连接
      this.connFactory.closeConnection(getConnection());
    }
  }

  /**
   * 创建数据库 PrepareStatement 对象 <br>
   *
   * @param sql SQL 语句
   * @return {@link Query}
   */
  public Query createStatement(String sql) {
    return this.createStatement(sql, false);
  }

  /**
   * 创建数据库 PrepareStatement 对象 <br>
   *
   * @param sql             SQL 语句
   * @param autoGeneratedPK 是否生成主键
   * @return {@link Query}
   */
  public Query createStatement(String sql, boolean autoGeneratedPK) {

    this.autoGeneratedPK = autoGeneratedPK;
    try {
      if (this.autoGeneratedPK)
        statement = getConnection().prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
      else
        statement = getConnection().prepareStatement(sql);
    } catch (SQLException ex) {
      throw new DBException(ex, "Error preparing statement: {}", ex.getMessage());
    }

    return this;
  }

  public int doExecute(String sql,
                       Collection<?> params,
                       boolean autoGeneratedPK,
                       ThrowingConsumer<PreparedStatement, SQLException> psConsumer,
                       ThrowingConsumer<ResultSet, SQLException> rsConsumer) {
    return this.createStatement(sql, autoGeneratedPK)
               .addParameters(params)
               .addParameters(psConsumer)
               .execute(rsConsumer);
  }

  public int[] doExecuteBatch(String sql, Collection<Collection<?>> batchParams, boolean autoGeneratedPK, ThrowingConsumer<ResultSet, SQLException> consumer) {
    Query query = this.createStatement(sql, autoGeneratedPK);
    if (CollUtil.isNotEmpty(batchParams)) {
      for (Collection<?> params : batchParams) {
        query.addParameters(params).addBatch();
      }
    }
    return query.executeBatch(consumer);
  }

  public void setKey(Attribute attr, Object entity, ResultSet rs) throws SQLException {
    if (rs.next()) {
      attr.getFieldVisitor().setValue(entity, rs.getObject(1));
    }
  }

  public <TModel> void setKeys(Attribute attr, Collection<TModel> entities, ResultSet rs) throws SQLException {
    for (TModel entity : entities) {
      setKey(attr, entity, rs);
    }
  }

  /**
   * 批量增加参数
   *
   * @param params 参数集合
   * @return {@link Query}
   */
  public Query addParameters(Collection<?> params) {
    Assert.notNull(this.statement);

    if (CollUtil.isEmpty(params)) return this;

    int paramIndex = 1;
    for (Object param : params) {
      addParameter(paramIndex++, param);
    }
    return this;
  }

  /**
   * 增加参数
   *
   * @param paramIndex 参数序号，从 1 开始
   * @param param      参数
   * @return {@link Query}
   */
  @SuppressWarnings({"unchecked", "UnusedReturnValue"})
  public Query addParameter(int paramIndex, Object param) {

    Assert.isTrue(paramIndex > 0);

    try {
      if (Objects.isNull(param)) {
        statement.setObject(paramIndex, null);
      } else {
        PropertyHandlerFactory.getInstance(param.getClass()).addParameter(statement, paramIndex, param);
      }
    } catch (SQLException ex) {
      throw new DBException(ex, "Error adding parameter: {}", ex.getMessage());
    }
    return this;
  }

  /**
   * 手动增加参数或对 {@link PreparedStatement} 进行设置
   *
   * @param consumer {@link ThrowingConsumer}
   * @return {@link Query}
   */
  public Query addParameters(ThrowingConsumer<PreparedStatement, SQLException> consumer) {
    try {
      if (Objects.nonNull(consumer))
        consumer.accept(this.statement);
      return this;
    } catch (SQLException e) {
      throw new DBException(e, "Error add parameters: {}", e.getMessage());
    }
  }

  public <TModel> List<TModel> list(Class<TModel> modelClass) {
    try {
      int fetchSize = this.getDbConfig().getFetchSize();
      if (fetchSize > 0)
        statement.setFetchSize(fetchSize);
      resultSet = statement.executeQuery();
      return DBConvert.toList(modelClass, resultSet);
    } catch (SQLException ex) {
      throw new DBException(ex, "Error execute query: {}", ex.getMessage());
    }
  }

  public int execute(ThrowingConsumer<ResultSet, SQLException> consumer) {
    try {
      int result = statement.executeUpdate();
      if (Objects.isNull(consumer)) return result;

      if (this.autoGeneratedPK) {
        this.resultSet = statement.getGeneratedKeys();
        consumer.accept(resultSet);
      }

      return result;
    } catch (SQLException e) {
      throw new DBException(e, "Error execute update: {}", e.getMessage());
    }
  }

  /**
   * 调用 {@link PreparedStatement#addBatch()} 并提交执行
   *
   * @return {@link Query}
   */
  @SuppressWarnings("UnusedReturnValue")
  public Query addBatch() {
    try {
      this.statement.addBatch();
      int sysBatchSize = this.getDbConfig().getBatchSize();
      if (sysBatchSize > 0) {
        if (++currentBatchSize % sysBatchSize == 0) {
          this.statement.executeBatch();
        }
      }
    } catch (SQLException e) {
      throw new DBException(e, "Error add batch: {}", e.getMessage());
    }
    return this;
  }


  public int[] executeBatch(ThrowingConsumer<ResultSet, SQLException> consumer) {
    try {
      currentBatchSize = 0;
      int[] result = statement.executeBatch();
      if (Objects.isNull(consumer)) return result;

      if (this.autoGeneratedPK) {
        this.resultSet = statement.getGeneratedKeys();
        consumer.accept(resultSet);
      }
      return result;
    } catch (SQLException e) {
      throw new DBException(e, "Error execute batch: {}", e.getMessage());
    }
  }

  public Savepoint setSavepoint() {
    try {
      return getConnection().setSavepoint();
    } catch (SQLException e) {
      throw new DBException(e, "Fail to set save point: {}", e.getMessage());
    }
  }

  public Savepoint setSavepoint(String name) {
    try {
      return getConnection().setSavepoint(name);
    } catch (SQLException e) {
      throw new DBException(e, "Fail to set save point: {}", e.getMessage());
    }
  }

  public void rollback() {
    rollback(null);
  }

  public void rollback(Savepoint savepoint) {
    try {
      if (Objects.isNull(savepoint)) {
        getConnection().rollback();
      } else {
        getConnection().rollback(savepoint);
      }

    } catch (SQLException e) {
      throw new DBException(e, "Fail to rollback transaction: {}", e.getMessage());
    }
  }

  public void commit() {
    Connection connection = getConnection();
    try {
      if (connection == null || connection.isClosed()) return;
      if (!connection.getAutoCommit()) {
        connection.commit();
      }
    } catch (SQLException e) {
      throw new DBException(e, "Fail to committed transaction: {}", e.getMessage());
    }
  }
}
