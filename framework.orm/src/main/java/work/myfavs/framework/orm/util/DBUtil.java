package work.myfavs.framework.orm.util;

import cn.hutool.core.collection.CollectionUtil;
import java.sql.*;
import java.util.Collection;
import java.util.Objects;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import work.myfavs.framework.orm.meta.handler.PropertyHandlerFactory;
import work.myfavs.framework.orm.util.exception.DBException;
import work.myfavs.framework.orm.util.func.ThrowingRunnable;

/** 数据库工具类 */
public class DBUtil {
  private static final Logger log = LoggerFactory.getLogger(DBUtil.class);

  /**
   * 创建用于查询的PreparedStatement
   *
   * @param conn Connection
   * @param sql SQL语句
   * @return PreparedStatement
   * @throws SQLException SQLException
   */
  public static PreparedStatement getPstForQuery(Connection conn, String sql) throws SQLException {
    return conn.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
  }

  /**
   * 创建用于查询的PreparedStatement
   *
   * @param conn Connection
   * @param sql SQL语句
   * @param params 查询参数
   * @return PreparedStatement
   * @throws SQLException SQLException
   */
  public static PreparedStatement getPstForQuery(Connection conn, String sql, Collection<?> params)
      throws SQLException {

    final PreparedStatement pst = getPstForQuery(conn, sql);
    return setParams(pst, params);
  }

  public static PreparedStatement getPstForUpdate(
      Connection conn, boolean autoGeneratedPK, String sql, Collection<?> params)
      throws SQLException {

    final PreparedStatement pst = getPstForUpdate(conn, autoGeneratedPK, sql);
    return setParams(pst, params);
  }

  public static PreparedStatement getPstForUpdate(
      Connection conn, boolean autoGeneratedPK, String sql) throws SQLException {
    if (autoGeneratedPK) {
      return conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
    } else {
      return conn.prepareStatement(sql);
    }
  }

  public static int executeBatch(
      PreparedStatement pst, Collection<Collection<?>> params, int batchSize) throws SQLException {
    int result = 0, execIdx = 0;
    for (Collection<?> param : params) {
      setParams(pst, param);
      pst.addBatch();
      execIdx++;
      if (execIdx % batchSize == 0 || execIdx == params.size()) {
        result += pst.executeBatch().length;
        pst.clearBatch();
      }
    }

    return result;
  }

  /**
   * 设置 PreparedStatement 参数
   *
   * @param preparedStatement PreparedStatement
   * @param params 参数数组
   * @return PreparedStatement
   * @throws SQLException SQLException
   */
  private static PreparedStatement setParams(
      PreparedStatement preparedStatement, Collection<?> params) throws SQLException {
    if (CollectionUtil.isEmpty(params)) return preparedStatement;

    int index = 1;
    for (Object param : params) {
      if (Objects.isNull(param)) {
        preparedStatement.setObject(index++, null);
        continue;
      }
      PropertyHandlerFactory.getInstance(param.getClass())
          .addParameter(preparedStatement, index++, param);
    }

    return preparedStatement;
  }

  public static int executeUpdate(PreparedStatement preparedStatement) throws SQLException {
    return preparedStatement.executeUpdate();
  }

  /**
   * 提交事务
   *
   * @param connection Connection
   */
  public static void commit(Connection connection) {
    try {
      if (connection == null || connection.isClosed()) return;
      if (!connection.getAutoCommit()) {
        connection.commit();
      }
    } catch (SQLException e) {
      throw new DBException(e, "Fail to committed transaction");
    }
  }

  public static Savepoint setSavepoint(Connection connection) {
    try {
      return connection.setSavepoint();
    } catch (SQLException e) {
      throw new DBException(e, "Fail to set save point");
    }
  }

  public static Savepoint setSavepoint(Connection connection, String name) {
    try {
      return connection.setSavepoint(name);
    } catch (SQLException e) {
      throw new DBException(e, "Fail to set save point");
    }
  }

  public static void rollback(Connection connection) {
    assert Objects.nonNull(connection);
    rollback(connection, null);
  }

  public static void rollback(Connection connection, Savepoint savepoint) {
    try {
      if (Objects.isNull(savepoint)) {
        connection.rollback();
      } else {
        connection.rollback(savepoint);
      }

    } catch (SQLException e) {
      throw new DBException(e, "Fail to rollback transaction");
    }
  }

  /**
   * 关闭数据库连接
   *
   * @param connection Connection
   */
  public static void close(Connection connection) throws SQLException {
    if (connection == null) return;
    if (!connection.isClosed()) connection.close();
  }

  /**
   * 关闭 Statement
   *
   * @param statement Statement
   */
  public static void close(Statement statement) throws SQLException {
    if (statement == null) return;
    if (!statement.isClosed()) statement.close();
  }

  /**
   * 关闭 ResultSet
   *
   * @param resultSet ResultSet
   */
  public static void close(ResultSet resultSet) throws SQLException {
    if (resultSet == null) return;
    if (!resultSet.isClosed()) resultSet.close();
  }

  /**
   * 关闭 Connection、Statement、ResultSet
   *
   * @param resultSet ResultSet
   * @param statement Statement
   * @param connection Connection
   */
  public static void close(ResultSet resultSet, Statement statement, Connection connection) {
    close(resultSet, statement, () -> DBUtil.close(connection));
  }

  public static void close(
      ResultSet resultSet, Statement statement, ThrowingRunnable<Exception> connectionRunnable) {
    try {
      close(resultSet);
    } catch (SQLException e) {
      throw new DBException(e, "Fail to close the result set");
    } finally {
      try {
        close(statement);
      } catch (SQLException e) {
        throw new DBException(e, "Fail to close the statement");
      } finally {
        try {
          connectionRunnable.run();
        } catch (Exception e) {
          throw new DBException(e, "Fail to close the connection");
        }
      }
    }
  }
}
